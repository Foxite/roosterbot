using System;

namespace RoosterBot {
	/// <summary>
	/// Represents a version of something used within RoosterBot.
	/// </summary>
	public class Version : IEquatable<Version>, IComparable<Version> {
		/// <summary>
		/// Increments every time compatibility with old versions is broken (ie, something is removed)
		/// </summary>
		public uint Major { get; }

		/// <summary>
		/// Increments every time a new feature is added.
		/// </summary>
		public uint Feature { get; }

		/// <summary>
		/// Increments every time neither Major or Feature increment.
		/// </summary>
		public uint Minor { get; }

		/// <summary>
		/// Construct a new Version object.
		/// </summary>
		public Version(uint major, uint feature, uint minor) {
			Major = major;
			Feature = feature;
			Minor = minor;
		}

		/// <inheritdoc/>
		public override bool Equals(object? obj) => Equals(obj as Version);

		/// <inheritdoc/>
		public bool Equals(Version? other) {
			return !(other is null)
				&& Major   == other.Major
				&& Feature == other.Feature
				&& Minor   == other.Minor;
		}

		/// <inheritdoc/>
		public override string ToString() => $"{Major}.{Feature}.{Minor}";

		/// <inheritdoc/>
		public override int GetHashCode() {
			// Generated by Visual Studio 2019
			var hashCode = 145219157;
			hashCode = hashCode * -1521134295 + Major.GetHashCode();
			hashCode = hashCode * -1521134295 + Feature.GetHashCode();
			hashCode = hashCode * -1521134295 + Minor.GetHashCode();
			return hashCode;
		}
		
		/// <summary>
		/// Causes Version objects to be sorted oldest first.
		/// </summary>
		public int CompareTo(Version other) {
			if (this == other) {
				return 0;
			} else if (this > other) {
				return 1;
			} else {
				return -1;
			}
		}

		/// <summary>
		/// Parse a string and construct a new Version object.
		/// </summary>
		public static Version FromString(string input) {
			if (input is null) {
				throw new ArgumentNullException(nameof(input));
			}

			var split = input.Split('.');
			if (split.Length != 3) {
				throw new FormatException($"{nameof(input)} does not contain exactly 3 version terms.");
			}

			try {
				return new Version(uint.Parse(split[0]), uint.Parse(split[1]), uint.Parse(split[2]));
			} catch (Exception e) {
				throw new FormatException("One of the version terms is not a valid uint.", e);
			}
		}

		/// <inheritdoc/>
		public static bool operator ==(Version left, Version right) {
			return left.Major   == right.Major
				&& left.Feature == right.Feature
				&& left.Minor   == right.Minor;
		}

		/// <inheritdoc/>
		public static bool operator !=(Version left, Version right) {
			return !(left == right);
		}

		/// <inheritdoc/>
		public static bool operator >(Version left, Version right) {
			if (left.Major > right.Major) {
				return true;
			} else if (left.Major < right.Major) {
				return false;
			}

			if (left.Feature > right.Feature) {
				return true;
			} else if (left.Feature < right.Feature) {
				return false;
			}

			if (left.Minor > right.Minor) {
				return true;
			} else if (left.Minor < right.Minor) {
				return false;
			}

			return false;
		}

		/// <inheritdoc/>
		public static bool operator <(Version left, Version right) {
			if (left.Major < right.Major) {
				return true;
			} else if (left.Major > right.Major) {
				return false;
			}

			if (left.Feature < right.Feature) {
				return true;
			} else if (left.Feature > right.Feature) {
				return false;
			}

			if (left.Minor < right.Minor) {
				return true;
			} else if (left.Minor > right.Minor) {
				return false;
			}
			return false;
		}

		/// <inheritdoc/>
		public static bool operator >=(Version left, Version right) {
			return !(left < right);
		}

		/// <inheritdoc/>
		public static bool operator <=(Version left, Version right) {
			return !(left > right);
		}
	}
}
